---
id: glossary
title: React की शर्तों की शब्दावली
layout: docs
category: Reference
permalink: docs/glossary.html

---

## सिंगल पेज एप्लीकेशन {#single-page-application}

सिंगल पेज एप्लिकेशन एक ऐसा एप्लिकेशन है जो एकल HTML पेज को लोड करता है और आवश्यक सभी संपत्तियो को भी (जैसे जावास्क्रिप्ट और सीएसएस)जो एप्लिकेशन को चलाने के लिए आवश्यक है। पृष्ठ या बाद के पृष्ठों के साथ किसी भी बातचीत को सर्वर के लिए एक गोल यात्रा की आवश्यकता नहीं होती है जिसका अर्थ है कि पृष्ठ पुनः लोड नहीं किया गया है।

यद्यपि आप React में सिंगल पेज एप्लिकेशन का निर्माण कर सकते हैं, यह कोई आवश्यकता नहीं है। React का उपयोग मौजूदा वेबसाइटों के छोटे हिस्सों को अतिरिक्त अन्तरक्रियाशीलता के साथ बढ़ाने के लिए भी किया जा सकता है। React में लिखा कोड सर्वर पर PHP, या अन्य क्लाइंट-साइड लाइब्रेरी जैसी किसी चीज़ के द्वारा प्रदान किए गए मार्कअप के साथ शांतिपूर्वक सहवास कर सकता है। वास्तव में, ठीक इसी तरहे फेसबुक में React का उपयोग किया जा रहा है।

## ES6, ES2015, ES2016, आदि {#es6-es2015-es2016-etc}

ये सभी शब्द ECMAScript लैंग्वेज स्पेसिफिकेशन स्टैंडर्ड के सबसे हाल के संस्करणों को संदर्भित करते हैं, जो जावास्क्रिप्ट भाषा का एक कार्यान्वयन है। ES6 संस्करण (जिसे ES2015 के रूप में भी जाना जाता है) में पिछले संस्करणों में कई परिवर्धन शामिल हैं जैसे: तीर फ़ंक्शंस, क्लासेस, टेम्प्लेट शाब्दिक, `let` और `const` स्टेटमेंट। आप [यहां](https://en.wikipedia.org/wiki/ECMAScript#Versions) विशिष्ट संस्करणों के बारे में अधिक जान सकते हैं।

## कम्पाइलर {#compilers}

एक जावास्क्रिप्ट कंपाइलर जावास्क्रिप्ट कोड लेता है, और उसे बदल कर एक अलग प्रारूप में जावास्क्रिप्ट कोड देता है। सबसे आम उपयोग ES6 सिंटैक्स लेने और इसे ऊस सिंटैक्स में बदलने का है जिसे कि पुराने ब्राउज़र व्याख्या करने में सक्षम हैं। आमतौर पर React के साथ [बैबेल](https://babeljs.io/) कंपाइलर का उपयोग किया जाता है।

## बंडलर्स {#bundlers}

बंडलर्स अलग-अलग मॉड्यूल (अक्सर सैकड़ों में) के रूप में लिखे गए जावास्क्रिप्ट और सीएसएस कोड को कुछ फाइलों में एक साथ जोड़ते हैं जो की ब्राउज़रों के लिए बेहतर अनुकूलित हैं। आमतौर पर React एप्लिकेशन में उपयोग किए जाने वाले कुछ बंडलों में [वेबपैक](https://webpack.js.org/) और [ब्राउज़रीफ़ाय](http://browserify.org/) शामिल हैं।

## Package मैनेजर {#package-managers}

Package मैनेजर वे उपकरण हैं जो आपको अपनी परियोजना में निर्भरता का प्रबंधन करने की अनुमति देते हैं। [npm](https://www.npmjs.com/) और [Yarn](https://yarnpkg.com/) दो package मैनेजर हैं जो आमतौर पर React एप्लिकेशन में उपयोग किए जाते हैं। ये दोनों समान npm package रजिस्ट्री के लिए क्लाइंट हैं।

## सीडीएन {#cdn}

सीडीएन कंटेंट डिलीवरी नेटवर्क के लिए है। सीडीएन दुनिया भर में सर्वर के नेटवर्क से कैश्ड, स्थिर सामग्री वितरित करते हैं।

## JSX {#jsx}

JSX जावास्क्रिप्ट का एक सिंटैक्स एक्सटेंशन है। यह एक टेम्पलेट भाषा के समान है, लेकिन इसमें जावास्क्रिप्ट की पूरी शक्ति है। JSX `React.createElement()` कॉल में कम्पाइल होता है जो सादे जावास्क्रिप्ट ऑब्जेक्ट वापस करता है जिसे "React एलिमेंट्स" कहते हैं। JSX का मूल परिचय प्राप्त करने के लिए [यहां डॉक्स देखें](/docs/introducing-jsx.html) और JSX पर अधिक गहराई से ट्यूटोरियल [यहां](/docs/jsx-in-depth.html) देखें।

React DOM, HTML विशेषता नामों के बजाय कैमलकेस प्रॉपर्टी नेमिंग कन्वेंशन का उपयोग करता है। उदाहरण के लिए, `tabindex` JSX में `tabIndex` बन जाता है। विशेषता `class` को `className` के रूप में भी लिखा जाता है क्योंकि `class` जावास्क्रिप्ट में एक आरक्षित शब्द है:

```js
const name = 'Clementine';
ReactDOM.render(
  <h1 className="hello">My name is {name}!</h1>,
  document.getElementById('root')
);
```  

## [एलिमेंट्स](/docs/rendering-elements.html) {#elements}

React एलिमेंट्स React एप्लीकेशन के निर्माण खंड हैं। एक अधिक व्यापक रूप से ज्ञात अवधारणा "कौम्पोनॅन्ट्स" के साथ एलिमेंट्स को भ्रमित कर सकता है। एक एलिमेंट्स वर्णन करता है कि आप स्क्रीन पर क्या देखना चाहते हैं। React एलिमेंट्स अपरिवर्तनीय हैं।

```js
const element = <h1>Hello, world</h1>;
```

आमतौर पर, एलिमेंट्स का सीधे उपयोग नहीं किया जाता है, लेकिन कौम्पोनॅन्ट्स से वापस किये जाते हैं।

## [कौम्पोनॅन्ट्स](/docs/components-and-props.html) {#components}

React कौम्पोनॅन्ट्स छोटे, पुन: प्रयोज्य टुकड़े हैं जो पृष्ठ पर रेंडर करने के लिए एक React एलिमेंट्स को वापस करते हैं। React कौम्पोनॅन्ट का सबसे सरल संस्करण एक सादे जावास्क्रिप्ट फ़ंक्शन है जो एक React एलिमेंट देता है:

```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

कौम्पोनॅन्ट्स ES6 classes भी हो सकते हैं:

```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

कौम्पोनॅन्ट्स को कार्यक्षमता के अलग-अलग टुकड़ों में विभाजित किया जा सकता है और अन्य कौम्पोनॅन्ट्स के भीतर उपयोग किया जा सकता है। कौम्पोनॅन्ट्स अन्य कौम्पोनॅन्ट्स, arrays, strings और numbers को वापस कर सकते हैं। अंगूठे का एक अच्छा नियम यह है कि यदि आपके UI का एक हिस्सा कई बार उपयोग किया जाता है (बटन, पैनल, अवतार), या अपने आप में पर्याप्त जटिल है (ऐप, फीडस्टोरी, टिप्पणी), तो पुन: प्रयोज्य कौम्पोनॅन्ट होने के लिए यह एक अच्छा उम्मीदवार है । कौम्पोनॅन्ट नाम हमेशा एक कैपिटल लेटर (`<Wrapper/>` **not** `<wrapper/>`) से शुरू होना चाहिए। रेंडरिंग कौम्पोनॅन्ट्स के बारे में अधिक जानकारी के लिए [यह दस्तावेज़](/docs/components-and-props.html#rendering-a-component) देखें।

### [`props`](/docs/components-and-props.html) {#props}

`props` एक React कौम्पोनॅन्ट के लिए इनपुट हैं। वे डेटा हैं जो मूल कौम्पोनॅन्ट से चाइल्ड कौम्पोनॅन्ट तक जाते हैं।

याद रखें कि `props` को सिर्फ सिफ़ पढ़िये। उन्हें किसी भी तरह से संशोधित नहीं किया जाना चाहिए:

```js
// Wrong!
props.number = 42;
```

यदि आपको उपयोगकर्ता इनपुट या नेटवर्क प्रतिक्रिया के जवाब में कुछ मूल्य को संशोधित करने की आवश्यकता है, तो इसके बजाय `state` का उपयोग करें।

### `props.children` {#propschildren}


`props.children` हर कौम्पोनॅन्ट पर उपलब्ध है। इसमें किसी कौम्पोनॅन्ट के खुलने और बंद होने के बीच की सामग्री शामिल है। उदाहरण के लिए:

```js
<Welcome>Hello world!</Welcome>
```

String `Hello world!` `Welcome` कौम्पोनॅन्ट में `props.children` में उपलब्ध है:

```js
function Welcome(props) {
  return <p>{props.children}</p>;
}
```

classes के रूप में परिभाषित कौम्पोनॅन्ट्स के लिए, `this.props.children` का उपयोग करें:

```js
class Welcome extends React.Component {
  render() {
    return <p>{this.props.children}</p>;
  }
}
```

### [`state`](/docs/state-and-lifecycle.html#adding-local-state-to-a-class) {#state}

A component needs `state` when some data associated with it changes over time. For example, a `Checkbox` component might need `isChecked` in its state, and a `NewsFeed` component might want to keep track of `fetchedPosts` in its state.

The most important difference between `state` and `props` is that `props` are passed from a parent component, but `state` is managed by the component itself. A component cannot change its `props`, but it can change its `state`.

For each particular piece of changing data, there should be just one component that "owns" it in its state. Don't try to synchronize states of two different components. Instead, [lift it up](/docs/lifting-state-up.html) to their closest shared ancestor, and pass it down as props to both of them.

## [Lifecycle मेथड्स](/docs/state-and-lifecycle.html#adding-lifecycle-methods-to-a-class) {#lifecycle-methods}

Lifecycle मेथड्स कस्टम कार्यक्षमता हैं जो किसी कौम्पोनॅन्ट के विभिन्न चरणों के दौरान निष्पादित होते हैं। मेथड्स तब उपलब्ध  होते हैं जब कौम्पोनॅन्ट उपलब्ध होने के बाद DOM ([माउंटिंग](/docs/react-component.html#mounting)) में सम्मिलित होता हैं, जब कौम्पोनॅन्ट अपडेट करता है, और जब कौम्पोनॅन्ट अनमाउंट हो जाता है या DOM से हटा दिया जाता है।

 ## [नियंत्रित](/docs/forms.html#controlled-components) बनाम [अनियंत्रित कौम्पोनॅन्ट](/docs/uncontrolled-components.html)

फॉर्म इनपुट से निपटने के लिए React के दो अलग-अलग दृष्टिकोण हैं। 

एक इनपुट फॉर्म एलिमेंट जिसका मूल्य React द्वारा नियंत्रित किया जाता है, एक *नियंत्रित कौम्पोनॅन्ट* कहा जाता है। जब कोई उपयोगकर्ता एक नियंत्रित कौम्पोनॅन्ट में डेटा दर्ज करता है तो एक परिवर्तन ईवेंट हैंडलर चालू हो जाता है और आपका कोड तय करता है कि इनपुट वैध है (अपडेट किए गए मूल्य के साथ पुन: रेंडर करके)। यदि आप फिर से री-रेंडर नहीं करते हैं, तो फार्म एलिमेंट अपरिवर्तित रहेगा।

एक *अनियंत्रित कौम्पोनॅन्ट* React के बाहर फार्म एलिमेंट्स की तरह काम करता है। जब कोई उपयोगकर्ता किसी प्रपत्र फ़ील्ड (एक इनपुट बॉक्स, ड्रॉपडाउन, आदि) में डेटा इनपुट करता है, तो अपडेट की गई जानकारी React के कुछ भी करने की आवश्यकता के बिना परिलक्षित होती है। हालाँकि, इसका अर्थ यह भी है कि आप किसी निश्चित मान के लिए फ़ील्ड को बाध्य नहीं कर सकते।

ज्यादातर मामलों में आपको नियंत्रित कौम्पोनॅन्ट्स का उपयोग करना चाहिए।

## [Keys](/docs/lists-and-keys.html) {#keys}

"keys" एक विशेष string विशेषता है जिसे आपको एलिमेंट्स की सारणी बनाते समय शामिल करना होगा। keys React को पहचानने में मदद करती हैं कि कौन से आइटम बदल गए हैं, जोड़े गए हैं या हटा दिए गए हैं। तत्वों को एक स्थिर पहचान देने के लिए सरणी के अंदर तत्वों को कुंजी दी जानी चाहिए।

Keys को केवल एक ही array में सिबलिंग एलिमेंट्स के बीच अद्वितीय होना चाहिए। उन्हें संपूर्ण एप्लिकेशन या किसी एकल कौम्पोनॅन्ट में विशिष्ट होने की आवश्यकता नहीं है।

`Math.random()` की तरह keys को कुछ भी पास मत करो। यह महत्वपूर्ण है कि keys में फिर से रेंडर करने वालों की एक "स्थिर पहचान" हो ताकि React यह निर्धारित कर सके कि आइटम कब जोड़े गए, हटाए गए या फिर से ऑर्डर किए गए। आदर्श रूप से, keys को आपके डेटा से आने वाले अद्वितीय और स्थिर पहचानकर्ताओं के अनुरूप होना चाहिए, जैसे कि `post.id`.

## [Refs](/docs/refs-and-the-dom.html) {#refs}

React एक विशेष गुण का समर्थन करता है जिसे आप किसी भी कौम्पोनॅन्ट से जोड़ सकते हैं। `ref` गुण [`React.createRef()` फ़ंक्शन](/docs/react-api.html#reactcreateref) या कॉलबैक फ़ंक्शन, या string (लीगेसी API में) द्वारा बनाई गई ऑब्जेक्ट हो सकती है। जब `ref` गुण कॉलबैक फ़ंक्शन होती है, तो फ़ंक्शन अपने तर्क के रूप में अंतर्निहित DOM एलिमेंट या class इंस्टेंस उदाहरण (एलिमेंट के प्रकार के आधार पर) प्राप्त करता है। यह आपको DOM एलिमेंट या कौम्पोनॅन्ट इंस्टेंस तक सीधी पहुँच प्रदान करने की अनुमति देता है।

संयम से refs का प्रयोग करें। यदि आप अक्सर अपने ऐप में "चीजों को बनाने" के लिए refs का उपयोग करते हैं, तो [टॉप-डाउन डेटा प्रवाह](/docs/lifting-state-up.html) के साथ अधिक परिचित होने पर विचार करें।

## [इवेंट्स](/docs/handling-events.html) {#events}

React एलिमेंट्स के साथ इवेंट्स को संभालने से कुछ वाक्यात्मक अंतर होते हैं:

* React इवेंट हैंडलर्स को लोअरकेस के बजाय कैमकलेस का उपयोग करके नामित किया जाता है।
* JSX के साथ आप एक string के बजाय फंक्शन को हैंडलर के रूप में पास करते हैं।

## [Reconciliation](/docs/reconciliation.html) {#reconciliation}

When a component's props or state change, React decides whether an actual DOM update is necessary by comparing the newly returned element with the previously rendered one. When they are not equal, React will update the DOM. This process is called "reconciliation".
